<?xml version="1.0"?>
<docs>
    <members name="SqlRetryLogicBaseProvider">
        <SqlRetryLogicBaseProvider>
            <summary>Applies a retry logic on an operation through the `Execute` or `ExecuteAsync` functions.</summary>
        </SqlRetryLogicBaseProvider>
        <Retrying>
            <summary>Occurs exactly before applying the calculated delay time and executing the function as a next attempt.</summary>
            <value>
            <see cref="System.EventHandler" /> with event argument of <see cref="T:Microsoft.Data.SqlClient.SqlRetryingEventArgs" /> object can be subscribed.</value>
            <remarks>
            <format type="text/markdown"><![CDATA[  

> [IMPORTAMT!]
> Don't block the main execution by a time consumer action when an event occurs. For instance, if you like to log data in a file, run it in a new thread to avoid blocking the main execution line.  

]]>
            </format>
            </remarks>
        </Retrying>
        <RetryLogic>
            <summary>Defines a retry logic to make the decision in the encounter with intermittent exceptions.</summary>
            <remarks>
            <format type="text/markdown"><![CDATA[  

> [NOTE!]
> The `RetryLogic` property assigns to `SqlRetryLogicBaseProvider` creation and it's value uses as a template internally. Don't use it to study the status of the retry logic during and after the execution, instead of that, to collect these data use the <xref=E:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.Retrying> event.  

]]>
            </format>
            </remarks>
        </RetryLogic>
        <Execute>
            <typeparam name = "TResult">The object that the `function` returns when execute.</typeparam>
            <param name="sender">The source of the event.</param>
            <param name="function">The operaiton is likly be in the retry logic if transient condition happens.</param>
            <summary>Executes a function and applies the retry logic if it's enabled.
            
            Exceptions will be reported via an aggregate exception if the execution doesn't successful through the retry logic attempts.
            </summary>
            <returns>The return value of the `function` if it runs exception-free, otherwise returns an exception.</returns>
            <remarks>
            <format type="text/markdown"><![CDATA[  

> [NOTE!]
> The type of exception depends on the `function`'s internal implementation. But if the exception comes from the retry logic attempts it will be an <xref:System.AggregateException> that consists of all happen exceptions during the failed attempts.  

]]>
            </format>
            </remarks>
            <exception cref="T:System.ArgumentNullException">The `function` parameter couldn't be `null`.</exception>
            <exception cref="T:System.AggregateException">The collection of exceptions after the failed retry logic attempts.</exception>
        </Execute>
        <ExecuteAsync1>
            <typeparam name = "TResult">The object that the `function` returns in a Task when execute.</typeparam>
            <param name="sender">The source of the event.</param>
            <param name="function">The operaiton is likly be in the retry logic if transient condition happens.</param>
            <param name="cancellationToken">The cancellation instruction.</param>
            <summary>Executes a function and applies the retry logic if it's enabled. The cancellation token can be used to request that the operation be abandoned before the execution attempts exceeded.
            
            Exceptions will be reported via the returned Task object or an aggregate exception if the execution doesn't successful through the retry logic attempts.</summary>
            <returns>The return value of the `function` that represents in a Task if it runs exception-free, otherwise returns an exception.</returns>
            <remarks>
            <format type="text/markdown"><![CDATA[  

> [NOTE!]
> If the exception comes from the retry logic attempts it will be an <xref:System.AggregateException> that consists of all happen exceptions during the failed attempts.  

]]>
            </format>
            </remarks>
            <exception cref="T:System.ArgumentNullException">The `function` parameter couldn't be `null`.</exception>
            <exception cref="T:System.AggregateException">The collection of exceptions after the failed retry logic attempts.</exception>
        </ExecuteAsync1>
        <ExecuteAsync2>
            <param name="sender">The source of the event.</param>
            <param name="function">The operaiton is likly be in the retry logic if transient condition happens.</param>
            <param name="cancellationToken">The cancellation instruction.</param>
            <summary>Executes a function and applies the retry logic if it's enabled. The cancellation token can be used to request that the operation be abandoned before the execution attempts exceeded.
            
            Exceptions will be reported via the returned Task object or an aggregate exception if the execution doesn't successful through the retry logic attempts.</summary>
            <returns>A Task or an exception.</returns>
            <remarks>
            <format type="text/markdown"><![CDATA[  

> [NOTE!]
> If the exception comes from the retry logic attempts it will be an <xref:System.AggregateException> that consists of all happen exceptions during the failed attempts.  

]]>
            </format>
            </remarks>
            <exception cref="T:System.ArgumentNullException">The `function` parameter couldn't be `null`.</exception>
            <exception cref="T:System.AggregateException">The collection of exceptions after the failed retry logic attempts.</exception>
        </ExecuteAsync2>
    </members>
</docs>
