<?xml version="1.0"?>
<docs>
    <members name="SqlRetryLogicBase">
        <SqlRetryLogicBase>
            <summary>It retrieves next time interval with respect to the number of retries if transient condition happens.</summary>
        </SqlRetryLogicBase>
        <NumberOfTries>
            <summary>Maximume number of retries.</summary>
            <value>
            <see langword="int" /> that returns the maximum number of retry execution attemps is expected to attemp after the first failure.</value>
        </NumberOfTries>
        <Current>
            <summary>Current retry number starts from zero.</summary>
            <value>
            <see langword="int" /> that returns the number of retry execution attemps after the first failure.</value>
        </Current>
        <RetryIntervalEnumerator>
            <summary>The timer interval enumerator.</summary>
            <value>
            <see cref="T:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator" /> value that indicates an enumerator to Generate a sequence of time intervals.</value>
        </RetryIntervalEnumerator>
        <TransientPredicate>
            <summary>Delegate to a transient condition predicator. The function that this delegate points to it must return a true value when an expected transient exception happens.</summary>
            <value>
            <see cref="T:System.Predicate" /> value that delegate to a function that receives a <see cref="T:System.Exception" /> input parameter.</value>
        </TransientPredicate>
        <RetryCondition>
            <param name="sender">The sender object.</param>
            <summary>Pre-retry validation regarding to the sender state.</summary>
            <returns>Returns <see langword="true"/> if the sender is authorized to retry the operation.</returns>
            <remarks>
            <format type="text/markdown"><![CDATA[  

> [IMPORTANT!]
> Regarding the complexity of the retry logic in a **Transaction** without any knowledge about the business logic, we avoid applying the retry logic to an active transaction internally. This strategy should be managed at the application level.  

> [NOTE!]
> The `RetryCondition` is an extra condition that checks before executing the `TransientPredicate` and the default condition always returns **true**.  

]]></format>
            </remarks>
        </RetryCondition>
        <TryNextInterval>
            <param name="intervalTime">The interval time that is generated by the `RetryIntervalEnumerator`.</param>
            <summary>Try to get the next interval time by the enumerator if the counter does not exceed from the number of retries.</summary>
            <returns>Returns <see langword='true'/> if the number of retries does not exceed unless <see langword='false'/>.</returns>
        </TryNextInterval>
        <Reset>
            <summary>Set the counters and enumerator to default values for next use.</summary>
        </Reset>
        <Clone>
            <summary>Creates a new object that is a copy of the current instance.</summary>
            <returns>When implemented in a derived class, the method is expected to return a new object of the current instance. The default implementation throws NotImplementedException.</returns>
            <exception cref="T:System.NotImplementedException" >In all cases.</exception>
        </Clone>
    </members>
</docs>
